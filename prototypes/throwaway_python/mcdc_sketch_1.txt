Example of use of a proposed DSL for specifying program and test code generation. Based on ideas generated by the accompanying throwaway prototype.

* Defining the database of structures

We use s-expressions to create structures. Later we'll need to refer to the things in the structure. So something like:

    (1:if 2:cond 3:body1 4:body2)

It represents the abstract form only.

Some stuff might be the same between languages but other stuff might differ.

We might need higher-order definitions eventually? Like, there's theoretically if/elsif/else in Ada, how do we represent the branchiness of this, is it like a discriminant?

Structures will rely on certain things e.g. some variable or parameter being defined. Example,

  int decision_bedge(int x)
  {
     if(x)
	    ;
	 return 1;
  }

If I'm defining the inside on its own I need to tell the generator "this should be in a context where there's some x that can be used as a controlling Boolean expression".

Structures will also provide things; they can provide to placeholders and they can provide outside.

  int something(int x, int y)
  {
     int z = something_else(x, y);
	 if(z)
	 {
	    return 1;
     }
     return 2;
  }

In this case  

  int something(int x, int y)
  {
     [provides x, y]
	 
	 [needs x, y]
     int z = something_else(x, y);
	 [provides z]
	 
	 [needs z]
	 if(z)
	 {
	    return 1;
     }
     return 2;
	 [provides ()]
	 
	 [needs ()]
  }

->

  int something(int x, int y)
  {
     [provides x, y]
     <stuff>	 
	 [needs ()]
  }

and

	 [needs x, y]
     int z = something_else(x, y);
	 [provides z]
	
and	
	 [needs z]
	 if(z)
	 {
	    return 1;
     }
     return 2;
	 [provides ()]
	 
all work together.

You'll need a convenient way to get it to invent new names to have non-captured variables.


* Defining programs to output

Whole program should be a combination of these structures. In general we're just providing instructions like "use this template, insert this thing, tidy up all the references" which is a bit like a macro expansion with bells on. So

  template(params...)
  
  or
  
  (template params...)

like

  A = <<
  int something(int x, int y)
  {
     [provides x, y]
     <stuff>	 
	 [needs ()]
  }
  >>
  
and

  B = <<
	 [needs x, y]
     int z = something_else(x, y);
	 [provides z]
  >>
  
and

  C = <<	
	 [needs z]
	 if(z)
	 {
	    return 1;
     }
     return 2;
	 [provides ()]
  >>

then

  P = A( B ++ C )

* Defining how to output

You'll need to keep these things separate probably:

** the abstract s-expression structure
** a token sequence from the s-expression structure, suitable for a given language
** the actual text output into files

It's probably worth the same data structure being able to store a mixture of these things and you transform it in various ways until it's a single string. Basically un-parsing.

* All in one example

def [C] db.if = 
    (1:if 2:cond 3:body1 4:body2)
    cond: truthy_expr = simple_bool_expr
	body1: stmt = simple_stmt
	body2: stmt = simple_stmt
	pre this = pre cond u pre body1 u pre body2
	post this = post cond u (cond & post body1) u (!cond & post body2)
	cover
		1
			statement req 1 cov 1
		2
			decision req 1 cov (3 branch cov & 4 branch cov)
			inherit call, mcdc
		3
			branch req 1 cov (2 true)
			inherit all
		4
			branch req 1 cov (2 false)
			inherit all

def [C] db.simple_bool_expr =
    variable x
    (1:`x)
	pre this = {x: in truthy}
	post this = {}
	cover
		1
			literal_decision req 1 cov (x true & x false)
			mcdc
				cond 1 req 1 cov (x true & x false)
			
def [C] db.simple_stmt =
    ()
	pre this = {}
	post this = {}
	
def [C] get (if cond body1 body2) = << if(<cond>) <stmt body1> else <stmt body2> >>
def [C] get () = << >>
def [C] get (`x) = <<x>>

def [C]stmt a:(... <<;>>) = a
def [C]stmt a:(<<{>> ... <<}>>) = a
def [C]stmt a = a <<;>>

def [C] simple_if = (db.if)
# result:
# {x: in truthy} {} (1:if (2:`x) (3:_) (4:_)) { cover 1: statement req 1 cov 1; 2: decision req 1 cov (x true), mcdc cond 1 cov (x true); 3: statement req 1 cov (x true), branch req 1 cov (x true); 3: statement req 1 cov (x false), branch req 1 cov (x false) }

def [C] output = (get simple_if)
# result:
{x : in truthy} {} <<if(x) ; else ; >>

def [Ada]get (if cond body1 body2) = << if <cond> then <stmt body1> else <stmt body2> end if;>>
def [Ada]stmt a:(... <<;>>) = a
def [Ada]stmt a:(<<begin>> ... <<end>>) = a
def [Ada]stmt () = <<null;>>
def [Ada]stmt a = <<consume <a> ;>>


Notes from discussion:

* we definitely want a distinction between the data structure that represents the tree/tokens and the expression of combinations of rules. Where they overlap is that a rule that generates the tree wants to include a convenient representation of the tree, ideally in a form that has a nice repr(), which is why I went for s-expressions.

* The P = (A ++ B) stuff is very simplistic and really needs to be S-expression tree structures and not token streams, but I did a short-cut to avoid writing out all the rules again.

Immediate things to do:

* settle on a representation for the trees with pre/needs, post/provides, coverage, timing, complexity, other aspects as needed.
** Needs to be an internal data structure and a nice visual form to debug and discuss.

